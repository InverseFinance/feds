pragma solidity ^0.8.13;

import "src/interfaces/IERC20.sol";
import "src/interfaces/balancer/IVault.sol";
import "src/interfaces/aura/IAuraLocker.sol";
import "src/interfaces/aura/IAuraBalRewardPool.sol";
import "src/aura-fed/BalancerAdapter.sol";
import "src/MintingFed.sol";
import "src/LossyFed.sol";

interface IAuraBooster {
    function depositAll(uint _guagePid, bool _stake) external;
    function withdraw(uint _guagePid, uint _amount) external;
}

contract AuraFed is BalancerComposableStablepoolAdapter, LossyFed {

    IAuraBalRewardPool public dolaBptRewardPool;
    IAuraBooster public booster;
    IERC20 public constant BAL = IERC20(0xba100000625a3754423978a60c9317c58a424e3D);
    IERC20 public constant AURA = IERC20(0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF);
    uint public constant guagePid = 8;

    constructor(
            address dola_, 
            address dolaBptRewardPool_, 
            address bpt_,
            address booster_,
            address chair_,
            address guardian_,
            address gov_, 
            uint maxLossExpansionBps_,
            uint maxLossContractionBps_,
            uint maxLossTakeProfitBps_)
            LossyFed(dola_, gov_, chair_, guardian_, maxLossExpansionBps_, maxLossContractionBps_, maxLossTakeProfitBps_)
    {
        init(bpt_);
        dolaBptRewardPool = IAuraBalRewardPool(dolaBptRewardPool_);
        booster = IAuraBooster(booster_);
        BPT.approve(booster_, type(uint256).max);
    }

    /**
     * @notice Deposits amount of dola tokens into balancer, before locking with aura
     * @param dolaAmount Amount of dola token to deposit
     * @return claimsReceived Returns the amount of balancer pool tokens received
     */
    function _deposit(uint dolaAmount) internal override returns(uint claimsReceived) {
        require(msg.sender == chair, "ONLY CHAIR");
        DOLA.mint(address(this), dolaAmount);
        claimsReceived = _addLiquidity(dolaAmount, maxLossExpansionBps);
        booster.depositAll(guagePid, true);
    }
    /**
     * @notice Withdraws an amount of dola token to be burnt, contracting DOLA debt
     * @dev Be careful when setting maxLoss parameter. There will almost always be some loss from
     *  slippage + trading fees that may be incurred when withdrawing from a Balancer pool.
     *  On the other hand, setting the maxLoss too high, may cause you to be front run by MEV
     *  sandwhich bots, making sure your entire maxLoss is incurred.
     *  Recommended to always broadcast withdrawl transactions(contraction & takeProfits)
     *  through a frontrun protected RPC like Flashbots RPC.
     * @param amountDola The amount of dola tokens to withdraw. Note that more tokens may
     *  be withdrawn than requested, as price is calculated by debts to strategies, but strategies
     *  may have outperformed price of dola token.
     * @return claimsUsed The amoutn of balancer pools tokens spent on withdrawing.
     * @return dolaReceived The DOLA received from the withdrawal
     */
    function _withdraw(uint amountDola) internal override returns(uint claimsUsed, uint dolaReceived){
        require(msg.sender == chair, "ONLY CHAIR");
        //Calculate how many lp tokens are needed to withdraw the dola
        uint claimsBefore = claimsSupply();
        uint bptNeeded = bptNeededForDola(amountDola);
        require(bptNeeded <= claimsSupply(), "Not enough BPT tokens");

        //Withdraw BPT tokens from aura, but don't claim rewards
        require(dolaBptRewardPool.withdrawAndUnwrap(bptNeeded, false), "AURA WITHDRAW FAILED");

        //Withdraw DOLA from balancer pool
        uint dolaWithdrawn = _removeLiquidity(amountDola, maxLossContractionBps);
        require(dolaWithdrawn > 0, "Must contract");
        return(claimsBefore - claimsSupply(), dolaWithdrawn);
    }

    /**
     * @notice Withdraws every remaining balLP token. Can take up to maxLossContractionBps in loss, compared to debt.
     * @dev It will be necessary to call takeProfit to withdraw any rewards.
     * @return claimsUsed The amoutn of balancer pools tokens spent on withdrawing.
     * @return dolaReceived The DOLA received from the withdrawal
     */
    function _withdrawAll() internal override returns(uint claimsUsed, uint dolaReceived){
        uint totalClaims = claimsSupply();
        uint claimsToUnstake = dolaBptRewardPool.balanceOf(address(this));
        require(dolaBptRewardPool.withdrawAndUnwrap(claimsToUnstake, false), "AURA WITHDRAW FAILED");
        uint dolaWithdrawn = _removeAllLiquidity(maxLossContractionBps);
        require(dolaWithdrawn > 0, "MUST CONTRACT");
        return(totalClaims - claimsSupply(), dolaWithdrawn);
    }

    /**
     * @notice Withdraws the profit generated by aura staking
     * @param flag Flags special behaviour that may only be allowed by special roles.
     *  Flag = 1: Takes profit on BPTs
     */
    function takeProfit(uint flag) override external {
        //This takes balLP at face value, but doesn't take into account slippage or fees
        //Worth considering that the additional transaction fees incurred by withdrawing the small amount of profit generated by tx fees,
        //may not eclipse additional transaction costs. Set harvestLP = false to only withdraw bal and aura rewards.
        uint bptValue = claimsSupply() * BPT.getRate() / 10**18;
        if(flag == 1 && bptValue > debt) {
            require(msg.sender == chair, "ONLY CHAIR CAN TAKE BPT PROFIT");
            uint dolaSurplus = bptValue - debt;
            uint bptToWithdraw = bptNeededForDola(dolaSurplus);
            if(bptToWithdraw > dolaBptRewardPool.balanceOf(address(this))){
                bptToWithdraw = dolaBptRewardPool.balanceOf(address(this));
            }
            require(dolaBptRewardPool.withdrawAndUnwrap(bptToWithdraw, false), "AURA WITHDRAW FAILED");
            uint dolaProfit = _removeLiquidity(dolaSurplus, maxLossTakeProfitBps);
            require(dolaProfit > 0, "NO PROFIT");
            DOLA.transfer(gov, dolaProfit);
        }

        require(dolaBptRewardPool.getReward(address(this), true), "Getting reward failed");
        uint balBalance = BAL.balanceOf(address(this));
        uint auraBalance = AURA.balanceOf(address(this));
        if(balBalance > 0) BAL.transfer(gov, balBalance);
        if(auraBalance > 0) AURA.transfer(gov, auraBalance);
    }

    /**
     * @notice Withdraws balancer pool tokens to governance in an emergency.
     * @dev Will ruin accounting of the contract
     */
    function emergencyWithdraw() onlyGov override external {
        require(dolaBptRewardPool.withdrawAndUnwrap(dolaBptRewardPool.balanceOf(address(this)), false), "AURA WITHDRAW FAILED");
        BPT.transfer(gov, BPT.balanceOf(address(this)));
    }

    /**
     * @notice Migrates claims tokens and debt to the Migrator fed contract
     * @dev The calling migrator must increment its debt by amount returned by this call
     * @param claimsToMigrate Amount of claims tokens to migrate
     */
    function migrateTo(uint claimsToMigrate) onlyMigrator override external returns(uint){
        uint totalClaims = claimsSupply();
        require(totalClaims >= claimsToMigrate, "NOT ENOUGH CLAIMS");
        uint claimsToUnstake =  claimsToMigrate - BPT.balanceOf(address(this));
        require(dolaBptRewardPool.withdrawAndUnwrap(claimsToUnstake, false), "AURA WITHDRAW FAILED");
        uint debtToMigrate = debt * claimsToMigrate / totalClaims;
        BPT.transfer(migrator, claimsToMigrate);
        return debtToMigrate;
    }
    
    /**
    @notice View function for getting bpt tokens in the contract + aura dolaBptRewardPool
    */
    function claimsSupply() public view override returns(uint){
        return BPT.balanceOf(address(this)) + dolaBptRewardPool.balanceOf(address(this));
    }
}
